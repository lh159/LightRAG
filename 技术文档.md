# LightRAG标签体系演示Demo搭建指南

## 🎯 项目概述

基于LightRAG技术构建情感陪伴助手，集成智能标签体系，实现个性化用户画像和情感回应。

**核心特性**：
- 轻量化知识图谱存储
- 多用户隔离标签管理  
- 实时标签提取与权重更新
- 个性化情感陪伴回应

---

## 🏗️ 系统架构设计

```
LightRAG-TagSystem-Demo/
├── app/                        # 主应用目录
│   ├── core/                   # 核心模块
│   │   ├── lightrag_engine.py  # LightRAG引擎
│   │   ├── tag_extractor.py    # 标签提取器
│   │   ├── tag_manager.py      # 标签管理器
│   │   └── response_generator.py # 回应生成器
│   ├── models/                 # 数据模型
│   │   ├── user_model.py       # 用户模型
│   │   ├── tag_model.py        # 标签模型
│   │   └── knowledge_model.py  # 知识模型
│   ├── api/                    # API接口
│   │   ├── chat_api.py         # 聊天接口
│   │   ├── tag_api.py          # 标签管理接口
│   │   └── user_api.py         # 用户管理接口
│   └── utils/                  # 工具函数
│       ├── file_manager.py     # 文件管理
│       ├── llm_client.py       # LLM客户端
│       └── config.py           # 配置管理
├── user_data/                  # 用户数据目录
│   ├── user_123/              # 用户数据文件夹
│   │   ├── documents/         # 用户文档
│   │   ├── knowledge_graph/   # 知识图谱文件
│   │   ├── user_tags.json     # 用户标签
│   │   └── conversation_log.json # 对话记录
│   └── global/                # 全局配置
│       ├── tag_templates.json # 标签模板
│       └── system_config.json # 系统配置
├── web/                       # Web界面
│   ├── templates/             # HTML模板
│   ├── static/                # 静态资源
│   └── app.py                 # Flask应用
├── requirements.txt           # 依赖包
├── config.yaml               # 主配置文件
└── run_demo.py              # 启动脚本
```

---

## 📋 环境搭建步骤

### 第一步：基础环境准备

```bash
# 1. 创建项目目录
mkdir LightRAG-TagSystem-Demo
cd LightRAG-TagSystem-Demo

# 2. 创建Python虚拟环境
python -m venv lightrag_env
source lightrag_env/bin/activate  # Linux/Mac
# lightrag_env\Scripts\activate   # Windows

# 3. 安装依赖包
pip install -r requirements.txt
```

### 第二步：依赖包配置

```txt
# requirements.txt
lightrag==0.1.0
openai==1.3.0
chromadb==0.4.15
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
python-multipart==0.0.6
jinja2==3.1.2
aiofiles==23.2.1
sqlite3
pandas==2.1.3
numpy==1.24.3
networkx==3.2
flask==3.0.0
```

---

## 🔧 核心代码实现

### 1. LightRAG引擎集成 (app/core/lightrag_engine.py)

```python
import os
import json
from typing import Dict, List, Optional
from lightrag import LightRAG, QueryParam
from lightrag.llm import gpt_4o_mini_complete, gpt_4o_complete
from lightrag.embed import openai_embedding

class LightRAGEngine:
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.user_data_path = f"user_data/{user_id}"
        self.ensure_user_directory()
        
        # 初始化LightRAG实例
        self.rag = LightRAG(
            working_dir=self.user_data_path,
            llm_model_func=gpt_4o_mini_complete,
            embedding_func=openai_embedding,
        )
        
    def ensure_user_directory(self):
        """确保用户目录存在"""
        os.makedirs(self.user_data_path, exist_ok=True)
        os.makedirs(f"{self.user_data_path}/documents", exist_ok=True)
        os.makedirs(f"{self.user_data_path}/knowledge_graph", exist_ok=True)
        
    def insert_knowledge(self, text: str, metadata: Dict = None):
        """插入知识到用户知识库"""
        try:
            # 添加元数据标记
            if metadata:
                text = f"[metadata: {json.dumps(metadata)}]\n{text}"
            
            self.rag.insert(text)
            return {"status": "success", "message": "知识插入成功"}
        except Exception as e:
            return {"status": "error", "message": f"插入失败: {str(e)}"}
    
    def query_knowledge(self, query: str, mode: str = "hybrid") -> str:
        """查询知识库"""
        try:
            # 根据查询模式设置参数
            if mode == "naive":
                param = QueryParam(mode="naive")
            elif mode == "local":
                param = QueryParam(mode="local")
            elif mode == "global":
                param = QueryParam(mode="global")
            else:
                param = QueryParam(mode="hybrid")
            
            response = self.rag.query(query, param=param)
            return response
        except Exception as e:
            return f"查询错误: {str(e)}"
    
    def get_knowledge_graph(self):
        """获取知识图谱结构"""
        try:
            graph_path = f"{self.user_data_path}/graph_chunk_entity_relation.graphml"
            if os.path.exists(graph_path):
                # 这里可以解析GraphML文件返回图结构
                return {"status": "success", "graph_exists": True}
            else:
                return {"status": "success", "graph_exists": False}
        except Exception as e:
            return {"status": "error", "message": str(e)}
```

### 2. 标签提取器 (app/core/tag_extractor.py)

```python
import json
import re
from datetime import datetime
from typing import Dict, List
from dataclasses import dataclass
from app.utils.llm_client import LLMClient

@dataclass
class TagInfo:
    name: str
    confidence: float
    evidence: str
    category: str

class TagExtractor:
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.llm_client = LLMClient()
        self.tag_categories = {
            "emotional_traits": "情感特征",
            "interest_preferences": "兴趣偏好", 
            "interaction_habits": "互动习惯",
            "value_principles": "价值观"
        }
        
    def extract_tags_from_text(self, text: str, context: Dict = None) -> Dict[str, List[TagInfo]]:
        """从文本中提取标签"""
        
        # 构建提取prompt
        extraction_prompt = self._build_extraction_prompt(text, context)
        
        # 调用LLM提取
        try:
            llm_response = self.llm_client.complete(
                extraction_prompt, 
                max_tokens=300,
                temperature=0.3
            )
            
            # 解析LLM响应
            extracted_tags = self._parse_llm_response(llm_response, text)
            
            # 添加行为模式分析
            behavior_tags = self._analyze_behavior_patterns(text)
            
            # 融合结果
            final_tags = self._merge_tag_results(extracted_tags, behavior_tags)
            
            return final_tags
            
        except Exception as e:
            print(f"标签提取错误: {e}")
            return {}
    
    def _build_extraction_prompt(self, text: str, context: Dict = None) -> str:
        """构建标签提取的prompt"""
        context_info = ""
        if context:
            context_info = f"对话上下文: {context.get('previous_messages', '')}\n"
        
        prompt = f"""
        你是一个专业的心理分析师，请分析以下用户文本并提取标签。
        
        {context_info}
        用户文本: "{text}"
        
        请从以下4个维度提取标签（每个维度最多3个标签）：
        1. 情感特征 - 用户的情绪倾向和心理特点
        2. 兴趣偏好 - 用户感兴趣或反感的话题内容
        3. 互动习惯 - 用户的交流风格和回应偏好
        4. 价值观 - 用户的原则立场和底线禁忌
        
        输出JSON格式：
        {{
            "情感特征": [
                {{"tag": "标签名", "confidence": 0.8, "evidence": "支撑证据"}}
            ],
            "兴趣偏好": [...],
            "互动习惯": [...], 
            "价值观": [...]
        }}
        
        注意：
        - confidence范围0.1-1.0，表示该标签的确信度
        - evidence是从原文中提取的支撑该标签的具体句子
        - 如果某个维度没有明显特征，返回空数组
        """
        
        return prompt
    
    def _parse_llm_response(self, response: str, original_text: str) -> Dict[str, List[TagInfo]]:
        """解析LLM返回的标签"""
        try:
            # 提取JSON部分
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if not json_match:
                return {}
            
            json_str = json_match.group(0)
            tag_data = json.loads(json_str)
            
            parsed_tags = {}
            for category_cn, tags in tag_data.items():
                # 转换中文分类名为英文key
                category_en = self._get_category_key(category_cn)
                if category_en:
                    parsed_tags[category_en] = []
                    for tag_info in tags:
                        tag = TagInfo(
                            name=tag_info.get("tag", ""),
                            confidence=tag_info.get("confidence", 0.5),
                            evidence=tag_info.get("evidence", ""),
                            category=category_en
                        )
                        parsed_tags[category_en].append(tag)
            
            return parsed_tags
            
        except Exception as e:
            print(f"解析LLM响应错误: {e}")
            return {}
    
    def _get_category_key(self, category_cn: str) -> str:
        """根据中文分类名获取英文key"""
        for key, value in self.tag_categories.items():
            if value == category_cn:
                return key
        return ""
    
    def _analyze_behavior_patterns(self, text: str) -> Dict[str, List[TagInfo]]:
        """基于规则的行为模式分析"""
        behavior_tags = {}
        
        # 文本长度分析
        if len(text) > 100:
            behavior_tags["interaction_habits"] = [
                TagInfo("偏好详细表达", 0.6, f"文本长度{len(text)}字符", "interaction_habits")
            ]
        elif len(text) < 30:
            behavior_tags["interaction_habits"] = [
                TagInfo("偏好简短交流", 0.6, f"文本长度{len(text)}字符", "interaction_habits")
            ]
        
        # 情感词检测
        positive_words = ["开心", "高兴", "快乐", "满意", "不错", "好的"]
        negative_words = ["难过", "沮丧", "失望", "糟糕", "痛苦", "烦躁"]
        
        positive_count = sum(1 for word in positive_words if word in text)
        negative_count = sum(1 for word in negative_words if word in text)
        
        if positive_count > negative_count and positive_count > 0:
            if "emotional_traits" not in behavior_tags:
                behavior_tags["emotional_traits"] = []
            behavior_tags["emotional_traits"].append(
                TagInfo("情绪偏向积极", 0.7, f"积极词汇{positive_count}个", "emotional_traits")
            )
        elif negative_count > positive_count and negative_count > 0:
            if "emotional_traits" not in behavior_tags:
                behavior_tags["emotional_traits"] = []
            behavior_tags["emotional_traits"].append(
                TagInfo("情绪偏向消极", 0.7, f"消极词汇{negative_count}个", "emotional_traits")
            )
        
        return behavior_tags
    
    def _merge_tag_results(self, llm_tags: Dict, behavior_tags: Dict) -> Dict[str, List[TagInfo]]:
        """融合LLM提取和行为分析的结果"""
        merged = llm_tags.copy()
        
        for category, tags in behavior_tags.items():
            if category not in merged:
                merged[category] = []
            
            # 避免重复标签
            existing_names = [tag.name for tag in merged[category]]
            for tag in tags:
                if tag.name not in existing_names:
                    merged[category].append(tag)
        
        return merged
```

### 3. 标签管理器 (app/core/tag_manager.py)

```python
import json
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from app.core.tag_extractor import TagInfo

class TagManager:
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.user_data_path = f"user_data/{user_id}"
        self.tags_file = f"{self.user_data_path}/user_tags.json"
        self.timeline_file = f"{self.user_data_path}/tag_timeline.json"
        
        # 确保文件存在
        self._ensure_tag_files()
        
    def _ensure_tag_files(self):
        """确保标签文件存在"""
        if not os.path.exists(self.tags_file):
            self._create_empty_tags_file()
        if not os.path.exists(self.timeline_file):
            self._create_empty_timeline_file()
    
    def _create_empty_tags_file(self):
        """创建空的标签文件"""
        empty_tags = {
            "user_id": self.user_id,
            "created_at": datetime.now().isoformat(),
            "last_updated": datetime.now().isoformat(),
            "tag_dimensions": {
                "emotional_traits": {
                    "dimension_name": "情感特征维度",
                    "active_tags": [],
                    "dominant_tag": None,
                    "dimension_weight": 0.0,
                    "stability_score": 0.0
                },
                "interest_preferences": {
                    "dimension_name": "兴趣偏好维度", 
                    "active_tags": [],
                    "dominant_tag": None,
                    "dimension_weight": 0.0,
                    "stability_score": 0.0
                },
                "interaction_habits": {
                    "dimension_name": "互动习惯维度",
                    "active_tags": [],
                    "dominant_tag": None,
                    "dimension_weight": 0.0,
                    "stability_score": 0.0
                },
                "value_principles": {
                    "dimension_name": "价值观维度",
                    "active_tags": [],
                    "dominant_tag": None,
                    "dimension_weight": 0.0,
                    "stability_score": 0.0
                }
            },
            "computed_metrics": {
                "emotional_health_index": 0.5,
                "interest_concentration": 0.0,
                "interaction_dependency": 0.0,
                "overall_profile_maturity": 0.0
            }
        }
        
        with open(self.tags_file, 'w', encoding='utf-8') as f:
            json.dump(empty_tags, f, ensure_ascii=False, indent=2)
    
    def _create_empty_timeline_file(self):
        """创建空的时间轴文件"""
        empty_timeline = {
            "user_id": self.user_id,
            "created_at": datetime.now().isoformat(),
            "tag_events": []
        }
        
        with open(self.timeline_file, 'w', encoding='utf-8') as f:
            json.dump(empty_timeline, f, ensure_ascii=False, indent=2)
    
    def update_tags(self, extracted_tags: Dict[str, List[TagInfo]]) -> Dict:
        """更新用户标签"""
        # 加载当前标签
        current_tags = self._load_current_tags()
        
        # 更新各维度标签
        for dimension, new_tags in extracted_tags.items():
            if dimension in current_tags["tag_dimensions"]:
                self._update_dimension_tags(
                    current_tags["tag_dimensions"][dimension], 
                    new_tags
                )
        
        # 重新计算权重和指标
        self._recalculate_weights_and_metrics(current_tags)
        
        # 更新时间戳
        current_tags["last_updated"] = datetime.now().isoformat()
        
        # 保存到文件
        self._save_tags(current_tags)
        
        # 记录到时间轴
        self._record_tag_timeline(extracted_tags)
        
        return current_tags
    
    def _load_current_tags(self) -> Dict:
        """加载当前标签"""
        with open(self.tags_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def _update_dimension_tags(self, dimension_data: Dict, new_tags: List[TagInfo]):
        """更新单个维度的标签"""
        active_tags = dimension_data["active_tags"]
        
        for new_tag in new_tags:
            # 查找是否已存在相同标签
            existing_tag = None
            for tag in active_tags:
                if tag["tag_name"] == new_tag.name:
                    existing_tag = tag
                    break
            
            if existing_tag:
                # 强化已有标签
                existing_tag["evidence_count"] += 1
                existing_tag["last_reinforced"] = datetime.now().isoformat()
                existing_tag["total_confidence"] += new_tag.confidence
                existing_tag["avg_confidence"] = existing_tag["total_confidence"] / existing_tag["evidence_count"]
                
                # 添加新证据
                if "evidences" not in existing_tag:
                    existing_tag["evidences"] = []
                existing_tag["evidences"].append({
                    "text": new_tag.evidence,
                    "timestamp": datetime.now().isoformat(),
                    "confidence": new_tag.confidence
                })
                
                # 限制证据数量（保留最近10条）
                if len(existing_tag["evidences"]) > 10:
                    existing_tag["evidences"] = existing_tag["evidences"][-10:]
            else:
                # 添加新标签
                new_tag_data = {
                    "tag_name": new_tag.name,
                    "first_detected": datetime.now().isoformat(),
                    "last_reinforced": datetime.now().isoformat(),
                    "evidence_count": 1,
                    "total_confidence": new_tag.confidence,
                    "avg_confidence": new_tag.confidence,
                    "decay_rate": 0.1,
                    "evidences": [{
                        "text": new_tag.evidence,
                        "timestamp": datetime.now().isoformat(),
                        "confidence": new_tag.confidence
                    }]
                }
                active_tags.append(new_tag_data)
        
        # 应用时间衰减
        self._apply_time_decay(active_tags)
        
        # 限制标签数量（保留权重最高的20个）
        if len(active_tags) > 20:
            active_tags.sort(key=lambda x: x["avg_confidence"], reverse=True)
            dimension_data["active_tags"] = active_tags[:20]
    
    def _apply_time_decay(self, active_tags: List[Dict]):
        """应用时间衰减"""
        now = datetime.now()
        
        for tag in active_tags:
            last_reinforced = datetime.fromisoformat(tag["last_reinforced"])
            days_since_reinforced = (now - last_reinforced).days
            
            # 计算衰减因子
            decay_factor = max(0.1, 1.0 - (days_since_reinforced * tag["decay_rate"] / 30))
            tag["current_weight"] = tag["avg_confidence"] * decay_factor
    
    def _recalculate_weights_and_metrics(self, tags_data: Dict):
        """重新计算权重和指标"""
        dimensions = tags_data["tag_dimensions"]
        
        for dimension_key, dimension_data in dimensions.items():
            active_tags = dimension_data["active_tags"]
            
            if active_tags:
                # 找到主导标签（权重最高）
                dominant_tag = max(active_tags, key=lambda x: x.get("current_weight", 0))
                dimension_data["dominant_tag"] = dominant_tag["tag_name"]
                
                # 计算维度权重
                dimension_data["dimension_weight"] = dominant_tag.get("current_weight", 0)
                
                # 计算稳定性评分（基于标签数量和平均置信度）
                avg_confidence = sum(tag.get("avg_confidence", 0) for tag in active_tags) / len(active_tags)
                tag_count_factor = min(1.0, len(active_tags) / 10.0)
                dimension_data["stability_score"] = avg_confidence * tag_count_factor
            else:
                dimension_data["dominant_tag"] = None
                dimension_data["dimension_weight"] = 0.0
                dimension_data["stability_score"] = 0.0
        
        # 计算综合指标
        self._compute_overall_metrics(tags_data)
    
    def _compute_overall_metrics(self, tags_data: Dict):
        """计算综合指标"""
        dimensions = tags_data["tag_dimensions"]
        metrics = tags_data["computed_metrics"]
        
        # 情感健康指数 (基于情感特征维度)
        emotional_dim = dimensions.get("emotional_traits", {})
        emotional_tags = emotional_dim.get("active_tags", [])
        
        positive_weight = 0
        negative_weight = 0
        for tag in emotional_tags:
            tag_name = tag["tag_name"]
            weight = tag.get("current_weight", 0)
            
            if any(word in tag_name for word in ["乐观", "积极", "开朗", "自信"]):
                positive_weight += weight
            elif any(word in tag_name for word in ["焦虑", "消极", "悲观", "敏感"]):
                negative_weight += weight
        
        total_emotional_weight = positive_weight + negative_weight
        if total_emotional_weight > 0:
            metrics["emotional_health_index"] = (positive_weight - negative_weight * 0.5) / total_emotional_weight
        else:
            metrics["emotional_health_index"] = 0.5
        
        # 兴趣集中度
        interest_dim = dimensions.get("interest_preferences", {})
        interest_tags = interest_dim.get("active_tags", [])
        
        if interest_tags:
            weights = [tag.get("current_weight", 0) for tag in interest_tags]
            sum_weights = sum(weights)
            sum_squares = sum(w**2 for w in weights)
            metrics["interest_concentration"] = sum_squares / (sum_weights**2) if sum_weights > 0 else 0
        else:
            metrics["interest_concentration"] = 0
        
        # 互动依赖度（基于互动习惯标签）
        interaction_dim = dimensions.get("interaction_habits", {})  
        interaction_tags = interaction_dim.get("active_tags", [])
        
        dependency_indicators = ["需要安慰", "寻求认可", "依赖他人", "需要倾听"]
        independence_indicators = ["独立思考", "自主决策", "偏好独处"]
        
        dependency_weight = 0
        independence_weight = 0
        
        for tag in interaction_tags:
            tag_name = tag["tag_name"]
            weight = tag.get("current_weight", 0)
            
            if any(indicator in tag_name for indicator in dependency_indicators):
                dependency_weight += weight
            elif any(indicator in tag_name for indicator in independence_indicators):
                independence_weight += weight
        
        total_interaction_weight = dependency_weight + independence_weight
        if total_interaction_weight > 0:
            metrics["interaction_dependency"] = dependency_weight / total_interaction_weight
        else:
            metrics["interaction_dependency"] = 0.5
        
        # 整体画像成熟度
        total_dimensions = len(dimensions)
        active_dimensions = sum(1 for dim in dimensions.values() if dim["dimension_weight"] > 0.1)
        avg_stability = sum(dim["stability_score"] for dim in dimensions.values()) / total_dimensions
        
        metrics["overall_profile_maturity"] = (active_dimensions / total_dimensions) * avg_stability
    
    def _save_tags(self, tags_data: Dict):
        """保存标签数据"""
        with open(self.tags_file, 'w', encoding='utf-8') as f:
            json.dump(tags_data, f, ensure_ascii=False, indent=2)
    
    def _record_tag_timeline(self, extracted_tags: Dict[str, List[TagInfo]]):
        """记录标签时间轴"""
        timeline_data = self._load_timeline()
        
        event = {
            "timestamp": datetime.now().isoformat(),
            "event_type": "tag_extraction",
            "extracted_tags": {}
        }
        
        for dimension, tags in extracted_tags.items():
            event["extracted_tags"][dimension] = [
                {
                    "tag_name": tag.name,
                    "confidence": tag.confidence,
                    "evidence": tag.evidence
                }
                for tag in tags
            ]
        
        timeline_data["tag_events"].append(event)
        
        # 限制时间轴长度（保留最近100个事件）
        if len(timeline_data["tag_events"]) > 100:
            timeline_data["tag_events"] = timeline_data["tag_events"][-100:]
        
        with open(self.timeline_file, 'w', encoding='utf-8') as f:
            json.dump(timeline_data, f, ensure_ascii=False, indent=2)
    
    def _load_timeline(self) -> Dict:
        """加载时间轴数据"""
        with open(self.timeline_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def get_user_tags(self) -> Dict:
        """获取用户标签"""
        return self._load_current_tags()
    
    def get_dimension_weight(self, dimension: str) -> float:
        """获取维度权重"""
        tags_data = self._load_current_tags()
        return tags_data["tag_dimensions"].get(dimension, {}).get("dimension_weight", 0.0)
    
    def get_tag_timeline(self) -> Dict:
        """获取标签时间轴"""
        return self._load_timeline()
```

### 4. 个性化回应生成器 (app/core/response_generator.py)

```python
from typing import Dict, List
from app.core.lightrag_engine import LightRAGEngine
from app.core.tag_manager import TagManager
from app.utils.llm_client import LLMClient

class ResponseGenerator:
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.lightrag = LightRAGEngine(user_id)
        self.tag_manager = TagManager(user_id)
        self.llm_client = LLMClient()
        
    def generate_response(self, user_query: str, context: Dict = None) -> Dict:
        """生成个性化回应"""
        
        # 1. 获取用户标签
        user_tags = self.tag_manager.get_user_tags()
        
        # 2. 基于标签生成检索策略
        search_strategy = self._generate_search_strategy(user_tags, user_query)
        
        # 3. 使用LightRAG检索相关知识
        relevant_knowledge = self.lightrag.query_knowledge(
            user_query, 
            mode=search_strategy.get("search_mode", "hybrid")
        )
        
        # 4. 构建个性化回应prompt
        personalized_prompt = self._build_response_prompt(
            user_query, 
            relevant_knowledge, 
            user_tags, 
            search_strategy,
            context
        )
        
        # 5. 生成回应
        response = self.llm_client.complete(
            personalized_prompt,
            max_tokens=500,
            temperature=0.7
        )
        
        # 6. 后处理和安全检查
        final_response = self._post_process_response(response, search_strategy)
        
        return {
            "response": final_response,
            "search_strategy": search_strategy,
            "knowledge_used": relevant_knowledge[:200] + "..." if len(relevant_knowledge) > 200 else relevant_knowledge,
            "user_profile_snapshot": self._get_profile_snapshot(user_tags)
        }
    
    def _generate_search_strategy(self, user_tags: Dict, query: str) -> Dict:
        """基于用户标签生成检索策略"""
        strategy = {
            "search_mode": "hybrid",
            "response_tone": "warm",
            "response_style": "balanced",
            "content_filters": [],
            "boost_topics": [],
            "avoid_topics": [],
            "emotional_adaptation": "neutral"
        }
        
        dimensions = user_tags.get("tag_dimensions", {})
        
        # 基于情感特征调整
        emotional_dim = dimensions.get("emotional_traits", {})
        if emotional_dim.get("dimension_weight", 0) > 0.5:
            dominant_emotional = emotional_dim.get("dominant_tag", "")
            
            if "敏感" in dominant_emotional or "焦虑" in dominant_emotional:
                strategy["response_tone"] = "gentle"
                strategy["content_filters"].extend(["批评", "否定", "失败"])
                strategy["emotional_adaptation"] = "supportive"
            elif "乐观" in dominant_emotional or "积极" in dominant_emotional:
                strategy["response_tone"] = "upbeat"
                strategy["emotional_adaptation"] = "encouraging"
        
        # 基于兴趣偏好调整
        interest_dim = dimensions.get("interest_preferences", {})
        interest_tags = interest_dim.get("active_tags", [])
        
        for tag in interest_tags:
            if tag.get("current_weight", 0) > 0.6:
                tag_name = tag["tag_name"]
                if "宠物" in tag_name:
                    strategy["boost_topics"].append("宠物")
                elif "音乐" in tag_name:
                    strategy["boost_topics"].append("音乐")
                elif "科技" in tag_name:
                    strategy["boost_topics"].append("科技")
                # 添加反感话题到避免列表
                elif "反感" in tag_name or "讨厌" in tag_name:
                    avoid_topic = tag_name.replace("反感", "").replace("讨厌", "")
                    strategy["avoid_topics"].append(avoid_topic)
        
        # 基于互动习惯调整
        interaction_dim = dimensions.get("interaction_habits", {})
        interaction_tags = interaction_dim.get("active_tags", [])
        
        for tag in interaction_tags:
            if tag.get("current_weight", 0) > 0.6:
                tag_name = tag["tag_name"]
                if "简短" in tag_name:
                    strategy["response_style"] = "concise"
                elif "详细" in tag_name:
                    strategy["response_style"] = "detailed"
                elif "幽默" in tag_name:
                    strategy["response_tone"] = "humorous"
                elif "正式" in tag_name:
                    strategy["response_tone"] = "formal"
        
        return strategy
    
    def _build_response_prompt(self, query: str, knowledge: str, user_tags: Dict, 
                             strategy: Dict, context: Dict = None) -> str:
        """构建个性化回应prompt"""
        
        # 提取关键用户特征
        profile_summary = self._extract_profile_summary(user_tags)
        
        # 构建上下文信息
        context_info = ""
        if context and context.get("conversation_history"):
            recent_messages = context["conversation_history"][-3:]  # 最近3条消息
            context_info = f"最近对话:\n" + "\n".join([f"- {msg}" for msg in recent_messages]) + "\n\n"
        
        # 构建内容过滤指令
        filter_instructions = ""
        if strategy.get("content_filters"):
            filter_instructions = f"注意避免提及: {', '.join(strategy['content_filters'])}\n"
        
        # 构建话题引导指令
        topic_guidance = ""
        if strategy.get("boost_topics"):
            topic_guidance = f"可以适当引入用户感兴趣的话题: {', '.join(strategy['boost_topics'])}\n"
        
        prompt = f"""
        你是一个温暖的情感陪伴助手，请基于以下信息生成个性化回应。
        
        {context_info}用户问题: "{query}"
        
        相关知识:
        {knowledge}
        
        用户特征:
        {profile_summary}
        
        回应要求:
        - 语气风格: {strategy.get('response_tone', 'warm')}
        - 回应风格: {strategy.get('response_style', 'balanced')}
        - 情感适配: {strategy.get('emotional_adaptation', 'neutral')}
        {filter_instructions}{topic_guidance}
        
        请生成一个200字以内的个性化回应，要体现出对用户特征的理解和关怀。
        """
        
        return prompt
    
    def _extract_profile_summary(self, user_tags: Dict) -> str:
        """提取用户画像摘要"""
        dimensions = user_tags.get("tag_dimensions", {})
        summary_parts = []
        
        for dim_key, dim_data in dimensions.items():
            if dim_data.get("dimension_weight", 0) > 0.3:
                dim_name = dim_data.get("dimension_name", dim_key)
                dominant_tag = dim_data.get("dominant_tag")
                weight = dim_data.get("dimension_weight", 0)
                
                if dominant_tag:
                    summary_parts.append(f"- {dim_name}: {dominant_tag} (权重: {weight:.2f})")
        
        if summary_parts:
            return "\n".join(summary_parts)
        else:
            return "- 用户画像还在建立中，采用通用温和的回应方式"
    
    def _post_process_response(self, response: str, strategy: Dict) -> str:
        """后处理回应内容"""
        # 移除可能的有害内容
        avoid_topics = strategy.get("avoid_topics", [])
        for topic in avoid_topics:
            if topic in response:
                # 这里可以实现更复杂的内容替换逻辑
                response = response.replace(topic, "[相关话题]")
        
        # 根据风格调整长度
        if strategy.get("response_style") == "concise":
            # 如果要求简洁，截取前100字
            if len(response) > 100:
                response = response[:97] + "..."
        
        return response.strip()
    
    def _get_profile_snapshot(self, user_tags: Dict) -> Dict:
        """获取用户画像快照"""
        metrics = user_tags.get("computed_metrics", {})
        dimensions = user_tags.get("tag_dimensions", {})
        
        snapshot = {
            "emotional_health_index": metrics.get("emotional_health_index", 0.5),
            "profile_maturity": metrics.get("overall_profile_maturity", 0.0),
            "active_dimensions": []
        }
        
        for dim_key, dim_data in dimensions.items():
            if dim_data.get("dimension_weight", 0) > 0.1:
                snapshot["active_dimensions"].append({
                    "dimension": dim_data.get("dimension_name", dim_key),
                    "dominant_tag": dim_data.get("dominant_tag"),
                    "weight": dim_data.get("dimension_weight", 0)
                })
        
        return snapshot
```

### 5. Web界面和API (web/app.py)

```python
from flask import Flask, render_template, request, jsonify, session
import uuid
import json
from datetime import datetime
from app.core.lightrag_engine import LightRAGEngine
from app.core.tag_extractor import TagExtractor  
from app.core.tag_manager import TagManager
from app.core.response_generator import ResponseGenerator

app = Flask(__name__)
app.secret_key = 'lightrag_demo_secret_key'

@app.route('/')
def index():
    """主页"""
    return render_template('index.html')

@app.route('/api/chat', methods=['POST'])
def chat():
    """聊天接口"""
    try:
        data = request.json
        user_message = data.get('message', '')
        
        # 获取或创建用户ID
        if 'user_id' not in session:
            session['user_id'] = str(uuid.uuid4())
        
        user_id = session['user_id']
        
        # 初始化组件
        tag_extractor = TagExtractor(user_id)
        tag_manager = TagManager(user_id)
        response_generator = ResponseGenerator(user_id)
        
        # 提取标签
        extracted_tags = tag_extractor.extract_tags_from_text(user_message)
        
        # 更新标签
        updated_tags = tag_manager.update_tags(extracted_tags)
        
        # 生成回应
        response_data = response_generator.generate_response(user_message)
        
        # 记录对话
        conversation_log = {
            "timestamp": datetime.now().isoformat(),
            "user_message": user_message,
            "assistant_response": response_data["response"],
            "extracted_tags": {k: [{"name": tag.name, "confidence": tag.confidence} for tag in v] for k, v in extracted_tags.items()},
            "search_strategy": response_data["search_strategy"]
        }
        
        return jsonify({
            "success": True,
            "response": response_data["response"],
            "user_profile": response_data["user_profile_snapshot"],
            "extracted_tags": {k: [{"name": tag.name, "confidence": tag.confidence} for tag in v] for k, v in extracted_tags.items()},
            "conversation_log": conversation_log
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/profile')
def get_profile():
    """获取用户画像"""
    try:
        if 'user_id' not in session:
            return jsonify({"success": False, "error": "用户未初始化"})
        
        user_id = session['user_id']
        tag_manager = TagManager(user_id)
        user_tags = tag_manager.get_user_tags()
        
        return jsonify({
            "success": True,
            "user_tags": user_tags
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/add_knowledge', methods=['POST'])
def add_knowledge():
    """添加知识"""
    try:
        if 'user_id' not in session:
            return jsonify({"success": False, "error": "用户未初始化"})
        
        data = request.json
        knowledge_text = data.get('text', '')
        metadata = data.get('metadata', {})
        
        user_id = session['user_id']
        lightrag = LightRAGEngine(user_id)
        
        result = lightrag.insert_knowledge(knowledge_text, metadata)
        
        return jsonify(result)
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/reset_user', methods=['POST'])
def reset_user():
    """重置用户（新建用户会话）"""
    session.pop('user_id', None)
    return jsonify({"success": True, "message": "用户会话已重置"})

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```

### 6. HTML模板 (web/templates/index.html)

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LightRAG标签体系演示</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .chat-section {
            flex: 2;
            background: white;
            margin: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }
        
        .profile-section {
            flex: 1;
            background: white;
            margin: 20px 20px 20px 0;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
            overflow-y: auto;
        }
        
        .chat-header {
            background: #4A90E2;
            color: white;
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
        }
        
        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 10px;
            max-width: 80%;
        }
        
        .user-message {
            background: #007bff;
            color: white;
            margin-left: auto;
        }
        
        .assistant-message {
            background: white;
            border: 1px solid #e9ecef;
        }
        
        .chat-input {
            display: flex;
            padding: 20px;
            background: white;
            border-radius: 0 0 10px 10px;
            border-top: 1px solid #e9ecef;
        }
        
        .chat-input input {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
        }
        
        .chat-input button {
            margin-left: 10px;
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
        }
        
        .profile-title {
            color: #4A90E2;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #4A90E2;
        }
        
        .dimension-card {
            background: #f8f9fa;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        
        .tag-item {
            background: #e7f3ff;
            color: #0066cc;
            padding: 5px 10px;
            margin: 5px 5px 5px 0;
            border-radius: 15px;
            display: inline-block;
            font-size: 0.9em;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }
        
        .metric-item {
            background: #f0f8ff;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="chat-section">
            <div class="chat-header">
                <h2>🤖 LightRAG情感陪伴助手</h2>
                <p>集成智能标签体系的个性化聊天Demo</p>
            </div>
            
            <div class="chat-messages" id="chatMessages">
                <div class="message assistant-message">
                    <strong>助手:</strong> 你好！我是你的情感陪伴助手。我会通过我们的对话逐渐了解你的特点和偏好，为你提供更个性化的回应。随便聊些什么吧！ 😊
                </div>
            </div>
            
            <div class="chat-input">
                <input type="text" id="messageInput" placeholder="输入你想说的话..." 
                       onkeypress="if(event.key==='Enter') sendMessage()">
                <button onclick="sendMessage()">发送</button>
                <button onclick="addKnowledge()" style="background: #28a745;">添加知识</button>
                <button onclick="resetUser()" style="background: #dc3545;">重置</button>
            </div>
        </div>
        
        <div class="profile-section">
            <h2 class="profile-title">👤 用户画像</h2>
            
            <div id="profileContent">
                <p style="color: #666; text-align: center;">开始对话后，这里会显示你的个性化标签</p>
            </div>
            
            <div id="metricsSection" style="display: none;">
                <h3>📊 综合指标</h3>
                <div class="metrics-grid" id="metricsGrid">
                </div>
            </div>
        </div>
    </div>

    <script>
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            // 显示用户消息
            addMessageToChat('user', message);
            input.value = '';
            
            // 显示加载状态
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.classList.add('loading');
            
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ message: message })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // 显示助手回应
                    addMessageToChat('assistant', data.response);
                    
                    // 更新用户画像
                    updateProfile(data.user_profile);
                    
                    // 显示提取的标签（用于调试）
                    if (Object.keys(data.extracted_tags).length > 0) {
                        console.log('提取的标签:', data.extracted_tags);
                    }
                } else {
                    addMessageToChat('assistant', '抱歉，处理消息时出现错误：' + data.error);
                }
                
            } catch (error) {
                addMessageToChat('assistant', '网络连接错误，请稍后重试。');
                console.error('Error:', error);
            } finally {
                chatMessages.classList.remove('loading');
            }
        }
        
        function addMessageToChat(sender, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            
            if (sender === 'user') {
                messageDiv.innerHTML = `<strong>你:</strong> ${message}`;
            } else {
                messageDiv.innerHTML = `<strong>助手:</strong> ${message}`;
            }
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function updateProfile(profileData) {
            const profileContent = document.getElementById('profileContent');
            const metricsSection = document.getElementById('metricsSection');
            const metricsGrid = document.getElementById('metricsGrid');
            
            if (!profileData || profileData.active_dimensions.length === 0) {
                return;
            }
            
            // 更新维度信息
            let html = '';
            profileData.active_dimensions.forEach(dim => {
                html += `
                    <div class="dimension-card">
                        <h4>${dim.dimension}</h4>
                        <div class="tag-item">${dim.dominant_tag}</div>
                        <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
                            权重: ${(dim.weight * 100).toFixed(1)}%
                        </div>
                    </div>
                `;
            });
            
            profileContent.innerHTML = html;
            
            // 更新指标
            metricsGrid.innerHTML = `
                <div class="metric-item">
                    <div style="font-weight: bold;">情感健康</div>
                    <div style="font-size: 1.2em; color: ${profileData.emotional_health_index > 0.6 ? '#28a745' : profileData.emotional_health_index > 0.4 ? '#ffc107' : '#dc3545'};">
                        ${(profileData.emotional_health_index * 100).toFixed(0)}%
                    </div>
                </div>
                <div class="metric-item">
                    <div style="font-weight: bold;">画像成熟度</div>
                    <div style="font-size: 1.2em; color: #007bff;">
                        ${(profileData.profile_maturity * 100).toFixed(0)}%
                    </div>
                </div>
            `;
            
            metricsSection.style.display = 'block';
        }
        
        async function addKnowledge() {
            const text = prompt('请输入要添加到知识库的内容:');
            if (!text) return;
            
            try {
                const response = await fetch('/api/add_knowledge', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text: text })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    alert('知识添加成功！');
                } else {
                    alert('添加失败：' + data.message);
                }
            } catch (error) {
                alert('网络错误，请稍后重试');
            }
        }
        
        async function resetUser() {
            if (!confirm('确定要重置用户会话吗？这将清除当前的对话历史和用户画像。')) {
                return;
            }
            
            try {
                const response = await fetch('/api/reset_user', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // 清空聊天记录
                    document.getElementById('chatMessages').innerHTML = `
                        <div class="message assistant-message">
                            <strong>助手:</strong> 你好！我是你的情感陪伴助手。我会通过我们的对话逐渐了解你的特点和偏好，为你提供更个性化的回应。随便聊些什么吧！ 😊
                        </div>
                    `;
                    
                    // 重置用户画像
                    document.getElementById('profileContent').innerHTML = `
                        <p style="color: #666; text-align: center;">开始对话后，这里会显示你的个性化标签</p>
                    `;
                    
                    document.getElementById('metricsSection').style.display = 'none';
                    
                    alert('用户会话已重置！');
                } else {
                    alert('重置失败，请稍后重试');
                }
            } catch (error) {
                alert('网络错误，请稍后重试');
            }
        }
        
        // 页面加载时获取用户画像
        window.onload = async function() {
            try {
                const response = await fetch('/api/profile');
                const data = await response.json();
                
                if (data.success && data.user_tags.computed_metrics.overall_profile_maturity > 0) {
                    // 如果用户已有画像数据，显示它
                    const dimensions = data.user_tags.tag_dimensions;
                    const activeDimensions = [];
                    
                    for (const [key, dim] of Object.entries(dimensions)) {
                        if (dim.dimension_weight > 0.1) {
                            activeDimensions.push({
                                dimension: dim.dimension_name,
                                dominant_tag: dim.dominant_tag,
                                weight: dim.dimension_weight
                            });
                        }
                    }
                    
                    if (activeDimensions.length > 0) {
                        updateProfile({
                            active_dimensions: activeDimensions,
                            emotional_health_index: data.user_tags.computed_metrics.emotional_health_index,
                            profile_maturity: data.user_tags.computed_metrics.overall_profile_maturity
                        });
                    }
                }
            } catch (error) {
                console.log('获取用户画像失败:', error);
            }
        };
    </script>
</body>
</html>
```

### 7. 配置文件 (config.yaml)

```yaml
# LightRAG标签系统配置
app:
  name: "LightRAG-TagSystem-Demo"
  version: "1.0.0"
  debug: true

llm:
  provider: "openai"
  model: "gpt-3.5-turbo"
  api_key: "your-openai-api-key-here"
  max_tokens: 500
  temperature: 0.7

embedding:
  provider: "openai"
  model: "text-embedding-ada-002"
  
storage:
  type: "local"
  base_path: "./user_data"
  backup_enabled: true
  cleanup_days: 90

tag_system:
  dimensions:
    emotional_traits: "情感特征"
    interest_preferences: "兴趣偏好"
    interaction_habits: "互动习惯"
    value_principles: "价值观"
  
  extraction:
    max_tags_per_dimension: 5
    confidence_threshold: 0.3
    decay_rate: 0.1
  
  weights:
    time_decay_days: 30
    usage_boost_factor: 1.2
    consistency_weight: 0.8

web:
  host: "127.0.0.1"
  port: 5000
  secret_key: "lightrag_demo_secret_key"
```

### 8. 启动脚本 (run_demo.py)

```python
#!/usr/bin/env python3
"""
LightRAG标签体系演示Demo启动脚本
"""
import os
import sys
import yaml
from pathlib import Path

def load_config():
    """加载配置文件"""
    config_path = Path("config.yaml")
    if not config_path.exists():
        print("错误: 配置文件 config.yaml 不存在")
        sys.exit(1)
    
    with open(config_path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)

def setup_environment():
    """设置环境变量"""
    config = load_config()
    
    # 设置OpenAI API Key
    api_key = config.get('llm', {}).get('api_key')
    if not api_key or api_key == "your-openai-api-key-here":
        api_key = input("请输入你的OpenAI API Key: ").strip()
        if not api_key:
            print("错误: 需要OpenAI API Key才能运行Demo")
            sys.exit(1)
    
    os.environ['OPENAI_API_KEY'] = api_key
    
    return config

def create_directories():
    """创建必要的目录"""
    directories = [
        "user_data",
        "user_data/global", 
        "logs"
    ]
    
    for directory in directories:
        Path(directory).mkdir(parents=True, exist_ok=True)
    
    print("✅ 目录结构创建完成")

def check_dependencies():
    """检查依赖包"""
    required_packages = [
        "lightrag", "openai", "flask", "pydantic", "chromadb"
    ]
    
    missing_packages = []
    for package in required_packages:
        try:
            __import__(package)
        except ImportError:
            missing_packages.append(package)
    
    if missing_packages:
        print(f"错误: 缺少依赖包: {', '.join(missing_packages)}")
        print("请运行: pip install -r requirements.txt")
        sys.exit(1)
    
    print("✅ 依赖包检查通过")

def main():
    """主函数"""
    print("🚀 启动 LightRAG标签体系演示Demo...")
    
    # 检查依赖
    check_dependencies()
    
    # 设置环境
    config = setup_environment()
    
    # 创建目录
    create_directories()
    
    # 启动Web应用
    try:
        from web.app import app
        
        host = config.get('web', {}).get('host', '127.0.0.1')
        port = config.get('web', {}).get('port', 5000)
        debug = config.get('app', {}).get('debug', True)
        
        print(f"✅ Demo启动成功!")
        print(f"📱 访问地址: http://{host}:{port}")
        print("💡 使用说明:")
        print("   1. 在聊天界面与助手对话")
        print("   2. 观察右侧用户画像的实时更新")
        print("   3. 可以添加知识到个人知识库")
        print("   4. 重置按钮可以清除会话数据")
        print("\n🎯 开始体验个性化的情感陪伴吧!")
        
        app.run(host=host, port=port, debug=debug)
        
    except Exception as e:
        print(f"❌ 启动失败: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

---

## 🚀 部署运行步骤

### 1. 环境准备
```bash
# 克隆或创建项目目录
mkdir LightRAG-TagSystem-Demo
cd LightRAG-TagSystem-Demo

# 创建虚拟环境
python -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate   # Windows

# 安装依赖
pip install -r requirements.txt
```

### 2. 配置设置
```bash
# 编辑 config.yaml，填入你的 OpenAI API Key
# 或者在启动时会提示输入
```

### 3. 启动Demo
```bash
python run_demo.py
```

### 4. 访问测试
```bash
# 打开浏览器访问
http://127.0.0.1:5000
```

---

## 🎯 Demo功能特性

### 核心功能演示
1. **实时标签提取**: 每次对话自动提取用户特征标签
2. **动态权重更新**: 标签权重根据使用频率和时间衰减
3. **个性化回应**: 基于用户画像调整回应风格和内容
4. **知识库管理**: 支持添加个人知识到LightRAG
5. **用户画像可视化**: 实时显示标签维度和综合指标

### 技术特色
- **轻量化架构**: 使用本地JSON文件存储，无需数据库
- **用户隔离**: 每用户独立的文件夹和标签体系
- **模块化设计**: 核心组件可独立使用和扩展
- **响应式界面**: 现代化的Web界面，实时更新

这套Demo完整实现了我们讨论的标签体系设计，可以直接部署体验LightRAG+标签系统的强大功能！
