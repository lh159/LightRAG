# LightRAG标签系统 - 用户系统集成方案

## 🎯 项目概述

基于现有LightRAG标签系统，集成完整的用户管理系统，实现多用户隔离、用户认证、权限管理和数据安全。

**核心目标**：
- 多用户隔离与数据安全
- 用户注册、登录、权限管理
- 用户画像持久化存储
- 会话管理与状态保持
- 用户数据备份与恢复

---

## 🏗️ 系统架构设计

### 当前架构分析
```
LightRAG-TagSystem-Demo/
├── app/
│   ├── core/                   # 核心模块（已存在）
│   │   ├── lightrag_engine.py  # LightRAG引擎
│   │   ├── tag_extractor.py    # 标签提取器
│   │   ├── tag_manager.py      # 标签管理器
│   │   └── response_generator.py # 回应生成器
│   └── utils/                  # 工具函数
│       └── llm_client.py       # LLM客户端
├── web/                        # Web应用
│   ├── app.py                  # Flask应用
│   └── templates/              # 前端模板
├── user_data/                  # 用户数据（当前基于session）
└── config.yaml                 # 配置文件
```

### 目标架构设计
```
LightRAG-TagSystem-Demo/
├── app/
│   ├── core/                   # 核心模块
│   │   ├── lightrag_engine.py  # LightRAG引擎
│   │   ├── tag_extractor.py    # 标签提取器
│   │   ├── tag_manager.py      # 标签管理器
│   │   ├── response_generator.py # 回应生成器
│   │   └── user_manager.py     # 🆕 用户管理器
│   ├── models/                 # 🆕 数据模型
│   │   ├── user_model.py       # 用户模型
│   │   ├── session_model.py    # 会话模型
│   │   └── permission_model.py # 权限模型
│   ├── auth/                   # 🆕 认证模块
│   │   ├── auth_manager.py     # 认证管理器
│   │   ├── password_utils.py   # 密码工具
│   │   └── jwt_utils.py        # JWT工具
│   ├── api/                    # 🆕 API接口
│   │   ├── auth_api.py         # 认证API
│   │   ├── user_api.py         # 用户API
│   │   └── admin_api.py        # 管理API
│   └── utils/                  # 工具函数
│       ├── llm_client.py       # LLM客户端
│       ├── database.py         # 🆕 数据库工具
│       └── security.py         # 🆕 安全工具
├── web/
│   ├── app.py                  # 主应用
│   ├── templates/              # 前端模板
│   │   ├── index.html          # 主页
│   │   ├── login.html          # 🆕 登录页
│   │   ├── register.html       # 🆕 注册页
│   │   └── profile.html        # 🆕 用户资料页
│   └── static/                 # 🆕 静态资源
│       ├── css/
│       ├── js/
│       └── images/
├── database/                   # 🆕 数据库
│   ├── users.db               # SQLite用户数据库
│   └── migrations/            # 数据库迁移
├── user_data/                  # 用户数据目录
│   ├── user_123/              # 用户数据文件夹
│   └── global/                # 全局配置
└── config.yaml                 # 配置文件
```

---

## 📋 实施步骤

### 第一步：数据库设计与用户模型

#### 1.1 创建数据库工具 (app/utils/database.py)

```python
import sqlite3
import os
import json
from datetime import datetime
from typing import Dict, List, Optional
import hashlib
import secrets

class DatabaseManager:
    def __init__(self, db_path: str = "database/users.db"):
        self.db_path = db_path
        self.ensure_database_directory()
        self.init_database()
    
    def ensure_database_directory(self):
        """确保数据库目录存在"""
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
    
    def init_database(self):
        """初始化数据库表"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # 用户表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username VARCHAR(50) UNIQUE NOT NULL,
                    email VARCHAR(100) UNIQUE,
                    password_hash VARCHAR(255) NOT NULL,
                    salt VARCHAR(255) NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_login TIMESTAMP,
                    is_active BOOLEAN DEFAULT 1,
                    is_admin BOOLEAN DEFAULT 0,
                    profile_data TEXT,
                    settings TEXT
                )
            ''')
            
            # 会话表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS sessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    session_token VARCHAR(255) UNIQUE NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    expires_at TIMESTAMP NOT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    FOREIGN KEY (user_id) REFERENCES users (id)
                )
            ''')
            
            # 用户标签表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_tags (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    dimension VARCHAR(50) NOT NULL,
                    tag_name VARCHAR(100) NOT NULL,
                    confidence REAL DEFAULT 0.5,
                    evidence TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    is_active BOOLEAN DEFAULT 1,
                    FOREIGN KEY (user_id) REFERENCES users (id)
                )
            ''')
            
            # 用户知识库表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_knowledge (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    content TEXT NOT NULL,
                    metadata TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_accessed TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    access_count INTEGER DEFAULT 0,
                    FOREIGN KEY (user_id) REFERENCES users (id)
                )
            ''')
            
            conn.commit()
    
    def create_user(self, username: str, password: str, email: str = None) -> Dict:
        """创建新用户"""
        try:
            salt = secrets.token_hex(16)
            password_hash = self._hash_password(password, salt)
            
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO users (username, email, password_hash, salt)
                    VALUES (?, ?, ?, ?)
                ''', (username, email, password_hash, salt))
                
                user_id = cursor.lastrowid
                conn.commit()
                
                return {
                    "success": True,
                    "user_id": user_id,
                    "username": username
                }
        except sqlite3.IntegrityError:
            return {
                "success": False,
                "error": "用户名或邮箱已存在"
            }
        except Exception as e:
            return {
                "success": False,
                "error": f"创建用户失败: {str(e)}"
            }
    
    def authenticate_user(self, username: str, password: str) -> Dict:
        """用户认证"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, password_hash, salt, is_active
                    FROM users WHERE username = ?
                ''', (username,))
                
                result = cursor.fetchone()
                if not result:
                    return {"success": False, "error": "用户不存在"}
                
                user_id, username, stored_hash, salt, is_active = result
                
                if not is_active:
                    return {"success": False, "error": "账户已被禁用"}
                
                # 验证密码
                input_hash = self._hash_password(password, salt)
                if input_hash != stored_hash:
                    return {"success": False, "error": "密码错误"}
                
                # 更新最后登录时间
                cursor.execute('''
                    UPDATE users SET last_login = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (user_id,))
                conn.commit()
                
                return {
                    "success": True,
                    "user_id": user_id,
                    "username": username
                }
        except Exception as e:
            return {
                "success": False,
                "error": f"认证失败: {str(e)}"
            }
    
    def create_session(self, user_id: int, expires_hours: int = 24) -> str:
        """创建用户会话"""
        session_token = secrets.token_hex(32)
        expires_at = datetime.now().timestamp() + (expires_hours * 3600)
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO sessions (user_id, session_token, expires_at)
                VALUES (?, ?, datetime(?, 'unixepoch'))
            ''', (user_id, session_token, expires_at))
            conn.commit()
        
        return session_token
    
    def validate_session(self, session_token: str) -> Optional[int]:
        """验证会话并返回用户ID"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT user_id FROM sessions 
                    WHERE session_token = ? 
                    AND expires_at > CURRENT_TIMESTAMP
                    AND is_active = 1
                ''', (session_token,))
                
                result = cursor.fetchone()
                return result[0] if result else None
        except Exception:
            return None
    
    def _hash_password(self, password: str, salt: str) -> str:
        """密码哈希"""
        return hashlib.sha256((password + salt).encode()).hexdigest()
```

#### 1.2 创建用户模型 (app/models/user_model.py)

```python
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional
import json

@dataclass
class User:
    id: int
    username: str
    email: Optional[str]
    created_at: datetime
    last_login: Optional[datetime]
    is_active: bool
    is_admin: bool
    profile_data: Dict
    settings: Dict

@dataclass
class UserSession:
    id: int
    user_id: int
    session_token: str
    created_at: datetime
    expires_at: datetime
    is_active: bool

@dataclass
class UserTag:
    id: int
    user_id: int
    dimension: str
    tag_name: str
    confidence: float
    evidence: str
    created_at: datetime
    last_updated: datetime
    is_active: bool

class UserManager:
    def __init__(self, db_manager):
        self.db_manager = db_manager
    
    def get_user_by_id(self, user_id: int) -> Optional[User]:
        """根据ID获取用户"""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, email, created_at, last_login, 
                           is_active, is_admin, profile_data, settings
                    FROM users WHERE id = ?
                ''', (user_id,))
                
                result = cursor.fetchone()
                if not result:
                    return None
                
                return User(
                    id=result[0],
                    username=result[1],
                    email=result[2],
                    created_at=datetime.fromisoformat(result[3]),
                    last_login=datetime.fromisoformat(result[4]) if result[4] else None,
                    is_active=bool(result[5]),
                    is_admin=bool(result[6]),
                    profile_data=json.loads(result[7]) if result[7] else {},
                    settings=json.loads(result[8]) if result[8] else {}
                )
        except Exception as e:
            print(f"获取用户失败: {e}")
            return None
    
    def update_user_profile(self, user_id: int, profile_data: Dict) -> bool:
        """更新用户资料"""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE users SET profile_data = ?
                    WHERE id = ?
                ''', (json.dumps(profile_data), user_id))
                conn.commit()
                return True
        except Exception as e:
            print(f"更新用户资料失败: {e}")
            return False
    
    def get_user_tags(self, user_id: int) -> List[UserTag]:
        """获取用户标签"""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, user_id, dimension, tag_name, confidence,
                           evidence, created_at, last_updated, is_active
                    FROM user_tags WHERE user_id = ? AND is_active = 1
                    ORDER BY dimension, confidence DESC
                ''', (user_id,))
                
                results = cursor.fetchall()
                return [
                    UserTag(
                        id=row[0], user_id=row[1], dimension=row[2],
                        tag_name=row[3], confidence=row[4], evidence=row[5],
                        created_at=datetime.fromisoformat(row[6]),
                        last_updated=datetime.fromisoformat(row[7]),
                        is_active=bool(row[8])
                    )
                    for row in results
                ]
        except Exception as e:
            print(f"获取用户标签失败: {e}")
            return []
```

### 第二步：认证系统实现

#### 2.1 创建认证管理器 (app/auth/auth_manager.py)

```python
import jwt
import secrets
from datetime import datetime, timedelta
from typing import Optional, Dict
from flask import request, session

class AuthManager:
    def __init__(self, db_manager, secret_key: str):
        self.db_manager = db_manager
        self.secret_key = secret_key
    
    def login(self, username: str, password: str) -> Dict:
        """用户登录"""
        # 验证用户凭据
        auth_result = self.db_manager.authenticate_user(username, password)
        
        if not auth_result["success"]:
            return auth_result
        
        user_id = auth_result["user_id"]
        
        # 创建会话
        session_token = self.db_manager.create_session(user_id)
        
        # 生成JWT令牌
        jwt_token = self._generate_jwt_token(user_id, username)
        
        return {
            "success": True,
            "user_id": user_id,
            "username": username,
            "session_token": session_token,
            "jwt_token": jwt_token
        }
    
    def register(self, username: str, password: str, email: str = None) -> Dict:
        """用户注册"""
        # 验证输入
        validation_result = self._validate_registration_input(username, password, email)
        if not validation_result["success"]:
            return validation_result
        
        # 创建用户
        create_result = self.db_manager.create_user(username, password, email)
        
        if create_result["success"]:
            # 自动登录
            return self.login(username, password)
        else:
            return create_result
    
    def logout(self, session_token: str) -> bool:
        """用户登出"""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE sessions SET is_active = 0
                    WHERE session_token = ?
                ''', (session_token,))
                conn.commit()
                return True
        except Exception:
            return False
    
    def validate_token(self, token: str) -> Optional[Dict]:
        """验证JWT令牌"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=["HS256"])
            user_id = payload.get("user_id")
            username = payload.get("username")
            exp = payload.get("exp")
            
            if not user_id or not username or not exp:
                return None
            
            # 检查令牌是否过期
            if datetime.utcnow().timestamp() > exp:
                return None
            
            return {
                "user_id": user_id,
                "username": username
            }
        except jwt.InvalidTokenError:
            return None
    
    def get_current_user(self) -> Optional[Dict]:
        """获取当前用户"""
        # 从请求头获取令牌
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            token = auth_header[7:]
            return self.validate_token(token)
        
        # 从session获取
        if "user_id" in session:
            user_id = session["user_id"]
            user = self.db_manager.get_user_by_id(user_id)
            if user:
                return {
                    "user_id": user.id,
                    "username": user.username
                }
        
        return None
    
    def _generate_jwt_token(self, user_id: int, username: str) -> str:
        """生成JWT令牌"""
        payload = {
            "user_id": user_id,
            "username": username,
            "exp": datetime.utcnow() + timedelta(hours=24),
            "iat": datetime.utcnow()
        }
        return jwt.encode(payload, self.secret_key, algorithm="HS256")
    
    def _validate_registration_input(self, username: str, password: str, email: str = None) -> Dict:
        """验证注册输入"""
        if not username or len(username) < 3:
            return {"success": False, "error": "用户名至少需要3个字符"}
        
        if not password or len(password) < 6:
            return {"success": False, "error": "密码至少需要6个字符"}
        
        if email and "@" not in email:
            return {"success": False, "error": "邮箱格式不正确"}
        
        return {"success": True}
```

#### 2.2 创建认证装饰器 (app/auth/decorators.py)

```python
from functools import wraps
from flask import request, jsonify, session
from app.auth.auth_manager import AuthManager

def login_required(f):
    """登录必需装饰器"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        auth_manager = AuthManager(request.app.config['DB_MANAGER'], 
                                 request.app.config['SECRET_KEY'])
        
        current_user = auth_manager.get_current_user()
        if not current_user:
            return jsonify({
                "success": False,
                "error": "需要登录"
            }), 401
        
        # 将用户信息添加到请求上下文
        request.current_user = current_user
        return f(*args, **kwargs)
    
    return decorated_function

def admin_required(f):
    """管理员权限装饰器"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        auth_manager = AuthManager(request.app.config['DB_MANAGER'], 
                                 request.app.config['SECRET_KEY'])
        
        current_user = auth_manager.get_current_user()
        if not current_user:
            return jsonify({
                "success": False,
                "error": "需要登录"
            }), 401
        
        # 检查管理员权限
        user = auth_manager.db_manager.get_user_by_id(current_user["user_id"])
        if not user or not user.is_admin:
            return jsonify({
                "success": False,
                "error": "需要管理员权限"
            }), 403
        
        request.current_user = current_user
        return f(*args, **kwargs)
    
    return decorated_function
```

### 第三步：API接口实现

#### 3.1 认证API (app/api/auth_api.py)

```python
from flask import Blueprint, request, jsonify, session
from app.auth.auth_manager import AuthManager

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/register', methods=['POST'])
def register():
    """用户注册"""
    try:
        data = request.json
        username = data.get('username', '').strip()
        password = data.get('password', '')
        email = data.get('email', '').strip()
        
        auth_manager = AuthManager(
            request.app.config['DB_MANAGER'],
            request.app.config['SECRET_KEY']
        )
        
        result = auth_manager.register(username, password, email)
        
        if result["success"]:
            # 设置session
            session['user_id'] = result["user_id"]
            session['username'] = result["username"]
            
            return jsonify({
                "success": True,
                "message": "注册成功",
                "user": {
                    "id": result["user_id"],
                    "username": result["username"]
                },
                "token": result["jwt_token"]
            })
        else:
            return jsonify(result), 400
            
    except Exception as e:
        return jsonify({
            "success": False,
            "error": f"注册失败: {str(e)}"
        }), 500

@auth_bp.route('/login', methods=['POST'])
def login():
    """用户登录"""
    try:
        data = request.json
        username = data.get('username', '').strip()
        password = data.get('password', '')
        
        auth_manager = AuthManager(
            request.app.config['DB_MANAGER'],
            request.app.config['SECRET_KEY']
        )
        
        result = auth_manager.login(username, password)
        
        if result["success"]:
            # 设置session
            session['user_id'] = result["user_id"]
            session['username'] = result["username"]
            
            return jsonify({
                "success": True,
                "message": "登录成功",
                "user": {
                    "id": result["user_id"],
                    "username": result["username"]
                },
                "token": result["jwt_token"]
            })
        else:
            return jsonify(result), 401
            
    except Exception as e:
        return jsonify({
            "success": False,
            "error": f"登录失败: {str(e)}"
        }), 500

@auth_bp.route('/logout', methods=['POST'])
def logout():
    """用户登出"""
    try:
        auth_manager = AuthManager(
            request.app.config['DB_MANAGER'],
            request.app.config['SECRET_KEY']
        )
        
        # 清除session
        session.clear()
        
        # 如果有token，也清除会话
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            token = auth_header[7:]
            # 这里可以添加token黑名单逻辑
        
        return jsonify({
            "success": True,
            "message": "登出成功"
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": f"登出失败: {str(e)}"
        }), 500

@auth_bp.route('/profile', methods=['GET'])
def get_profile():
    """获取用户资料"""
    try:
        auth_manager = AuthManager(
            request.app.config['DB_MANAGER'],
            request.app.config['SECRET_KEY']
        )
        
        current_user = auth_manager.get_current_user()
        if not current_user:
            return jsonify({
                "success": False,
                "error": "需要登录"
            }), 401
        
        user = auth_manager.db_manager.get_user_by_id(current_user["user_id"])
        
        return jsonify({
            "success": True,
            "user": {
                "id": user.id,
                "username": user.username,
                "email": user.email,
                "created_at": user.created_at.isoformat(),
                "last_login": user.last_login.isoformat() if user.last_login else None,
                "is_admin": user.is_admin,
                "profile_data": user.profile_data,
                "settings": user.settings
            }
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": f"获取资料失败: {str(e)}"
        }), 500
```

#### 3.2 用户API (app/api/user_api.py)

```python
from flask import Blueprint, request, jsonify
from app.auth.decorators import login_required
from app.models.user_model import UserManager

user_bp = Blueprint('user', __name__)

@user_bp.route('/profile', methods=['PUT'])
@login_required
def update_profile():
    """更新用户资料"""
    try:
        data = request.json
        user_id = request.current_user["user_id"]
        
        user_manager = UserManager(request.app.config['DB_MANAGER'])
        
        # 更新资料
        profile_data = data.get('profile_data', {})
        success = user_manager.update_user_profile(user_id, profile_data)
        
        if success:
            return jsonify({
                "success": True,
                "message": "资料更新成功"
            })
        else:
            return jsonify({
                "success": False,
                "error": "资料更新失败"
            }), 500
            
    except Exception as e:
        return jsonify({
            "success": False,
            "error": f"更新资料失败: {str(e)}"
        }), 500

@user_bp.route('/tags', methods=['GET'])
@login_required
def get_user_tags():
    """获取用户标签"""
    try:
        user_id = request.current_user["user_id"]
        user_manager = UserManager(request.app.config['DB_MANAGER'])
        
        tags = user_manager.get_user_tags(user_id)
        
        # 按维度分组
        tags_by_dimension = {}
        for tag in tags:
            if tag.dimension not in tags_by_dimension:
                tags_by_dimension[tag.dimension] = []
            tags_by_dimension[tag.dimension].append({
                "id": tag.id,
                "tag_name": tag.tag_name,
                "confidence": tag.confidence,
                "evidence": tag.evidence,
                "created_at": tag.created_at.isoformat(),
                "last_updated": tag.last_updated.isoformat()
            })
        
        return jsonify({
            "success": True,
            "tags": tags_by_dimension
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": f"获取标签失败: {str(e)}"
        }), 500

@user_bp.route('/data/export', methods=['GET'])
@login_required
def export_user_data():
    """导出用户数据"""
    try:
        user_id = request.current_user["user_id"]
        user_manager = UserManager(request.app.config['DB_MANAGER'])
        
        # 获取用户信息
        user = user_manager.get_user_by_id(user_id)
        tags = user_manager.get_user_tags(user_id)
        
        # 获取用户知识库数据
        knowledge_data = user_manager.get_user_knowledge(user_id)
        
        export_data = {
            "user_info": {
                "id": user.id,
                "username": user.username,
                "email": user.email,
                "created_at": user.created_at.isoformat(),
                "last_login": user.last_login.isoformat() if user.last_login else None
            },
            "tags": [{
                "dimension": tag.dimension,
                "tag_name": tag.tag_name,
                "confidence": tag.confidence,
                "evidence": tag.evidence,
                "created_at": tag.created_at.isoformat()
            } for tag in tags],
            "knowledge": knowledge_data,
            "export_date": datetime.now().isoformat()
        }
        
        return jsonify({
            "success": True,
            "data": export_data
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": f"导出数据失败: {str(e)}"
        }), 500
```

### 第四步：前端界面实现

#### 4.1 登录页面 (web/templates/login.html)

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>登录 - LightRAG标签系统</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/auth.css') }}">
</head>
<body>
    <div class="auth-container">
        <div class="auth-card">
            <div class="auth-header">
                <h1>LightRAG标签系统</h1>
                <p>智能情感陪伴助手</p>
            </div>
            
            <div class="auth-tabs">
                <button class="tab-btn active" onclick="switchTab('login')">登录</button>
                <button class="tab-btn" onclick="switchTab('register')">注册</button>
            </div>
            
            <!-- 登录表单 -->
            <form id="loginForm" class="auth-form">
                <div class="form-group">
                    <label for="loginUsername">用户名</label>
                    <input type="text" id="loginUsername" name="username" required>
                </div>
                
                <div class="form-group">
                    <label for="loginPassword">密码</label>
                    <input type="password" id="loginPassword" name="password" required>
                </div>
                
                <button type="submit" class="auth-btn">登录</button>
            </form>
            
            <!-- 注册表单 -->
            <form id="registerForm" class="auth-form" style="display: none;">
                <div class="form-group">
                    <label for="registerUsername">用户名</label>
                    <input type="text" id="registerUsername" name="username" required>
                </div>
                
                <div class="form-group">
                    <label for="registerEmail">邮箱（可选）</label>
                    <input type="email" id="registerEmail" name="email">
                </div>
                
                <div class="form-group">
                    <label for="registerPassword">密码</label>
                    <input type="password" id="registerPassword" name="password" required>
                </div>
                
                <div class="form-group">
                    <label for="confirmPassword">确认密码</label>
                    <input type="password" id="confirmPassword" name="confirmPassword" required>
                </div>
                
                <button type="submit" class="auth-btn">注册</button>
            </form>
            
            <div id="message" class="message"></div>
        </div>
    </div>
    
    <script src="{{ url_for('static', filename='js/auth.js') }}"></script>
</body>
</html>
```

#### 4.2 认证样式 (web/static/css/auth.css)

```css
/* 认证页面样式 */
.auth-container {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.auth-card {
    background: white;
    border-radius: 20px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
    padding: 40px;
    width: 400px;
    max-width: 90vw;
}

.auth-header {
    text-align: center;
    margin-bottom: 30px;
}

.auth-header h1 {
    color: #333;
    margin-bottom: 10px;
    font-size: 28px;
}

.auth-header p {
    color: #666;
    font-size: 16px;
}

.auth-tabs {
    display: flex;
    margin-bottom: 30px;
    border-radius: 10px;
    background: #f5f5f5;
    padding: 5px;
}

.tab-btn {
    flex: 1;
    padding: 12px;
    border: none;
    background: transparent;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.3s ease;
}

.tab-btn.active {
    background: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    color: #667eea;
}

.auth-form {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.form-group {
    display: flex;
    flex-direction: column;
}

.form-group label {
    margin-bottom: 8px;
    color: #333;
    font-weight: 500;
}

.form-group input {
    padding: 12px 16px;
    border: 2px solid #e1e5e9;
    border-radius: 10px;
    font-size: 16px;
    transition: border-color 0.3s ease;
}

.form-group input:focus {
    outline: none;
    border-color: #667eea;
}

.auth-btn {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 15px;
    border-radius: 10px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.3s ease;
}

.auth-btn:hover {
    transform: translateY(-2px);
}

.message {
    margin-top: 20px;
    padding: 12px;
    border-radius: 8px;
    text-align: center;
    font-weight: 500;
}

.message.success {
    background: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
}

.message.error {
    background: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
}
```

#### 4.3 认证JavaScript (web/static/js/auth.js)

```javascript
// 认证页面JavaScript
let currentTab = 'login';

function switchTab(tab) {
    currentTab = tab;
    
    // 更新按钮状态
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
    
    // 切换表单显示
    if (tab === 'login') {
        document.getElementById('loginForm').style.display = 'block';
        document.getElementById('registerForm').style.display = 'none';
    } else {
        document.getElementById('loginForm').style.display = 'none';
        document.getElementById('registerForm').style.display = 'block';
    }
    
    // 清除消息
    clearMessage();
}

function showMessage(message, type = 'success') {
    const messageEl = document.getElementById('message');
    messageEl.textContent = message;
    messageEl.className = `message ${type}`;
}

function clearMessage() {
    const messageEl = document.getElementById('message');
    messageEl.textContent = '';
    messageEl.className = 'message';
}

// 登录表单处理
document.getElementById('loginForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const data = {
        username: formData.get('username'),
        password: formData.get('password')
    };
    
    try {
        const response = await fetch('/api/auth/login', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
        
        const result = await response.json();
        
        if (result.success) {
            showMessage('登录成功，正在跳转...', 'success');
            
            // 保存token
            localStorage.setItem('auth_token', result.token);
            
            // 跳转到主页
            setTimeout(() => {
                window.location.href = '/';
            }, 1000);
        } else {
            showMessage(result.error, 'error');
        }
    } catch (error) {
        showMessage('登录失败，请重试', 'error');
    }
});

// 注册表单处理
document.getElementById('registerForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const password = formData.get('password');
    const confirmPassword = formData.get('confirmPassword');
    
    if (password !== confirmPassword) {
        showMessage('两次输入的密码不一致', 'error');
        return;
    }
    
    const data = {
        username: formData.get('username'),
        password: password,
        email: formData.get('email') || null
    };
    
    try {
        const response = await fetch('/api/auth/register', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
        
        const result = await response.json();
        
        if (result.success) {
            showMessage('注册成功，正在跳转...', 'success');
            
            // 保存token
            localStorage.setItem('auth_token', result.token);
            
            // 跳转到主页
            setTimeout(() => {
                window.location.href = '/';
            }, 1000);
        } else {
            showMessage(result.error, 'error');
        }
    } catch (error) {
        showMessage('注册失败，请重试', 'error');
    }
});
```

### 第五步：主应用集成

#### 5.1 更新主应用 (web/app.py)

```python
import sys
import os

# 添加父目录到路径以便导入
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from flask import Flask, render_template, request, jsonify, session, redirect, url_for
import uuid
import json
from datetime import datetime
from app.core.lightrag_engine import LightRAGEngine
from app.core.tag_extractor import TagExtractor  
from app.core.tag_manager import TagManager
from app.core.response_generator import ResponseGenerator
from app.utils.database import DatabaseManager
from app.auth.auth_manager import AuthManager
from app.auth.decorators import login_required

# 导入API蓝图
from app.api.auth_api import auth_bp
from app.api.user_api import user_bp

app = Flask(__name__)
app.secret_key = 'lightrag_demo_secret_key'

# 初始化数据库
db_manager = DatabaseManager()
app.config['DB_MANAGER'] = db_manager

# 注册蓝图
app.register_blueprint(auth_bp, url_prefix='/api/auth')
app.register_blueprint(user_bp, url_prefix='/api/user')

@app.route('/')
def index():
    """主页 - 检查登录状态"""
    auth_manager = AuthManager(db_manager, app.secret_key)
    current_user = auth_manager.get_current_user()
    
    if not current_user:
        return redirect(url_for('login'))
    
    return render_template('index.html', user=current_user)

@app.route('/login')
def login():
    """登录页面"""
    auth_manager = AuthManager(db_manager, app.secret_key)
    current_user = auth_manager.get_current_user()
    
    if current_user:
        return redirect(url_for('index'))
    
    return render_template('login.html')

@app.route('/logout')
def logout():
    """登出"""
    session.clear()
    return redirect(url_for('login'))

@app.route('/api/chat', methods=['POST'])
@login_required
def chat():
    """聊天接口 - 需要登录"""
    try:
        data = request.json
        user_message = data.get('message', '')
        user_id = request.current_user["user_id"]
        
        # 初始化组件
        tag_extractor = TagExtractor(str(user_id))
        tag_manager = TagManager(str(user_id))
        response_generator = ResponseGenerator(str(user_id))
        
        # 提取标签
        extracted_tags = tag_extractor.extract_tags_from_text(user_message)
        
        # 更新标签
        updated_tags = tag_manager.update_tags(extracted_tags)
        
        # 生成回应
        response_data = response_generator.generate_response(user_message)
        
        return jsonify({
            "success": True,
            "response": response_data["response"],
            "user_profile": response_data["user_profile_snapshot"],
            "extracted_tags": {k: [{"name": tag.name, "confidence": tag.confidence} for tag in v] for k, v in extracted_tags.items()}
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/profile')
@login_required
def get_profile():
    """获取用户画像 - 需要登录"""
    try:
        user_id = request.current_user["user_id"]
        tag_manager = TagManager(str(user_id))
        user_tags = tag_manager.get_user_tags()
        
        return jsonify({
            "success": True,
            "user_tags": user_tags
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/add_knowledge', methods=['POST'])
@login_required
def add_knowledge():
    """添加知识 - 需要登录"""
    try:
        data = request.json
        knowledge_text = data.get('text', '')
        metadata = data.get('metadata', {})
        user_id = request.current_user["user_id"]
        
        lightrag = LightRAGEngine(str(user_id))
        result = lightrag.insert_knowledge(knowledge_text, metadata)
        
        return jsonify(result)
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/reset_user', methods=['POST'])
@login_required
def reset_user():
    """重置用户数据 - 需要登录"""
    try:
        user_id = request.current_user["user_id"]
        
        # 清除用户数据
        import shutil
        user_data_path = f"user_data/{user_id}"
        if os.path.exists(user_data_path):
            shutil.rmtree(user_data_path)
        
        return jsonify({
            "success": True,
            "message": "用户数据已重置"
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```

### 第六步：配置文件更新

#### 6.1 更新配置文件 (config.yaml)

```yaml
# LightRAG标签系统配置 - 用户系统版本
app:
  name: "LightRAG-TagSystem-Demo"
  version: "2.0.0"
  debug: true

# 数据库配置
database:
  type: "sqlite"
  path: "database/users.db"
  backup_enabled: true
  backup_interval_hours: 24

# 认证配置
auth:
  jwt_secret: "your-super-secret-jwt-key-change-this"
  session_timeout_hours: 24
  password_min_length: 6
  username_min_length: 3

# LLM配置
llm:
  provider: "deepseek"
  model: "deepseek-chat"
  api_key: "sk-2e4c8701d3e048b794939a432ab956ab"
  base_url: "https://api.deepseek.com"
  max_tokens: 500
  temperature: 0.7

# 嵌入配置
embedding:
  provider: "deepseek"
  model: "deepseek-chat"
  base_url: "https://api.deepseek.com"
  
# 存储配置
storage:
  type: "local"
  base_path: "./user_data"
  backup_enabled: true
  cleanup_days: 90

# 标签系统配置
tag_system:
  dimensions:
    emotional_traits: "情感特征"
    interest_preferences: "兴趣偏好"
    interaction_habits: "互动习惯"
    value_principles: "价值观"
  
  extraction:
    max_tags_per_dimension: 5
    confidence_threshold: 0.3
    decay_rate: 0.1
  
  weights:
    time_decay_days: 30
    usage_boost_factor: 1.2
    consistency_weight: 0.8

# Web配置
web:
  host: "127.0.0.1"
  port: 5000
  secret_key: "lightrag_demo_secret_key"
  session_timeout_hours: 24
```

### 第七步：依赖更新

#### 7.1 更新requirements.txt

```txt
# 核心依赖
lightrag==0.1.0b6
flask==2.3.3
openai==1.3.0
pyyaml==6.0.1
requests==2.31.0

# 用户系统新增依赖
pyjwt==2.8.0
cryptography==41.0.7
bcrypt==4.0.1

# 数据库依赖
sqlite3  # Python内置

# 开发工具
python-dotenv==1.0.0
```

### 第八步：数据库工具补充

#### 8.1 完善数据库管理器 (app/utils/database.py)

```python
# 在DatabaseManager类中添加以下方法

def get_connection(self):
    """获取数据库连接"""
    return sqlite3.connect(self.db_path)

def get_user_by_id(self, user_id: int) -> Optional[Dict]:
    """根据ID获取用户"""
    try:
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT id, username, email, created_at, last_login, 
                       is_active, is_admin, profile_data, settings
                FROM users WHERE id = ?
            ''', (user_id,))
            
            result = cursor.fetchone()
            if not result:
                return None
            
            return {
                "id": result[0],
                "username": result[1],
                "email": result[2],
                "created_at": result[3],
                "last_login": result[4],
                "is_active": bool(result[5]),
                "is_admin": bool(result[6]),
                "profile_data": json.loads(result[7]) if result[7] else {},
                "settings": json.loads(result[8]) if result[8] else {}
            }
    except Exception as e:
        print(f"获取用户失败: {e}")
        return None

def update_user_profile(self, user_id: int, profile_data: Dict) -> bool:
    """更新用户资料"""
    try:
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE users SET profile_data = ?
                WHERE id = ?
            ''', (json.dumps(profile_data), user_id))
            conn.commit()
            return True
    except Exception as e:
        print(f"更新用户资料失败: {e}")
        return False

def get_user_knowledge(self, user_id: int) -> List[Dict]:
    """获取用户知识库数据"""
    try:
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT content, metadata, created_at, last_accessed, access_count
                FROM user_knowledge WHERE user_id = ?
                ORDER BY last_accessed DESC
            ''', (user_id,))
            
            results = cursor.fetchall()
            return [
                {
                    "content": row[0],
                    "metadata": json.loads(row[1]) if row[1] else {},
                    "created_at": row[2],
                    "last_accessed": row[3],
                    "access_count": row[4]
                }
                for row in results
            ]
    except Exception as e:
        print(f"获取用户知识库失败: {e}")
        return []

def backup_database(self) -> bool:
    """备份数据库"""
    try:
        import shutil
        from datetime import datetime
        
        backup_dir = "database/backups"
        os.makedirs(backup_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = f"{backup_dir}/users_backup_{timestamp}.db"
        
        shutil.copy2(self.db_path, backup_path)
        return True
    except Exception as e:
        print(f"数据库备份失败: {e}")
        return False

def cleanup_expired_sessions(self) -> int:
    """清理过期会话"""
    try:
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE sessions SET is_active = 0
                WHERE expires_at < CURRENT_TIMESTAMP
            ''')
            affected_rows = cursor.rowcount
            conn.commit()
            return affected_rows
    except Exception as e:
        print(f"清理过期会话失败: {e}")
        return 0
```

### 第九步：安全工具实现

#### 9.1 创建安全工具 (app/utils/security.py)

```python
import hashlib
import secrets
import re
from typing import Dict, List

class SecurityUtils:
    @staticmethod
    def validate_password_strength(password: str) -> Dict:
        """验证密码强度"""
        errors = []
        
        if len(password) < 8:
            errors.append("密码至少需要8个字符")
        
        if not re.search(r"[a-z]", password):
            errors.append("密码需要包含小写字母")
        
        if not re.search(r"[A-Z]", password):
            errors.append("密码需要包含大写字母")
        
        if not re.search(r"\d", password):
            errors.append("密码需要包含数字")
        
        if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
            errors.append("密码需要包含特殊字符")
        
        return {
            "valid": len(errors) == 0,
            "errors": errors,
            "strength": "strong" if len(errors) == 0 else "weak"
        }
    
    @staticmethod
    def sanitize_input(text: str) -> str:
        """清理用户输入"""
        # 移除潜在的SQL注入字符
        dangerous_chars = ["'", '"', ';', '--', '/*', '*/']
        for char in dangerous_chars:
            text = text.replace(char, '')
        
        # 移除HTML标签
        import re
        text = re.sub(r'<[^>]+>', '', text)
        
        return text.strip()
    
    @staticmethod
    def generate_secure_token(length: int = 32) -> str:
        """生成安全令牌"""
        return secrets.token_urlsafe(length)
    
    @staticmethod
    def hash_password(password: str, salt: str = None) -> tuple:
        """哈希密码"""
        if salt is None:
            salt = secrets.token_hex(16)
        
        # 使用PBKDF2进行密码哈希
        import hashlib
        import hmac
        
        key = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt.encode('utf-8'),
            100000  # 迭代次数
        )
        
        return key.hex(), salt
    
    @staticmethod
    def verify_password(password: str, stored_hash: str, salt: str) -> bool:
        """验证密码"""
        try:
            computed_hash, _ = SecurityUtils.hash_password(password, salt)
            return hmac.compare_digest(computed_hash, stored_hash)
        except Exception:
            return False
```

### 第十步：部署和测试

#### 10.1 创建部署脚本 (deploy_user_system.py)

```python
#!/usr/bin/env python3
"""
用户系统部署脚本
"""
import os
import sys
import shutil
from pathlib import Path

def create_directories():
    """创建必要的目录"""
    directories = [
        "app/models",
        "app/auth", 
        "app/api",
        "app/utils",
        "web/static/css",
        "web/static/js",
        "web/static/images",
        "database",
        "database/backups",
        "logs"
    ]
    
    for directory in directories:
        Path(directory).mkdir(parents=True, exist_ok=True)
        print(f"✅ 创建目录: {directory}")

def install_dependencies():
    """安装依赖"""
    print("📦 安装依赖包...")
    os.system("pip install -r requirements.txt")

def setup_database():
    """设置数据库"""
    print("🗄️ 初始化数据库...")
    from app.utils.database import DatabaseManager
    
    db_manager = DatabaseManager()
    print("✅ 数据库初始化完成")

def create_admin_user():
    """创建管理员用户"""
    print("👤 创建管理员用户...")
    from app.utils.database import DatabaseManager
    
    db_manager = DatabaseManager()
    
    # 创建默认管理员账户
    admin_result = db_manager.create_user(
        username="admin",
        password="admin123",
        email="admin@lightrag.com"
    )
    
    if admin_result["success"]:
        print("✅ 管理员用户创建成功")
        print("   用户名: admin")
        print("   密码: admin123")
        print("   ⚠️  请在生产环境中修改默认密码！")
    else:
        print("❌ 管理员用户创建失败:", admin_result["error"])

def backup_existing_data():
    """备份现有数据"""
    print("💾 备份现有数据...")
    
    if os.path.exists("user_data"):
        backup_dir = f"backup_{int(time.time())}"
        shutil.copytree("user_data", backup_dir)
        print(f"✅ 数据已备份到: {backup_dir}")

def main():
    """主部署流程"""
    print("🚀 开始部署LightRAG用户系统...")
    
    # 1. 创建目录结构
    create_directories()
    
    # 2. 安装依赖
    install_dependencies()
    
    # 3. 设置数据库
    setup_database()
    
    # 4. 创建管理员用户
    create_admin_user()
    
    # 5. 备份现有数据
    backup_existing_data()
    
    print("\n🎉 用户系统部署完成！")
    print("\n📋 下一步操作:")
    print("1. 启动应用: python run_demo.py")
    print("2. 访问: http://127.0.0.1:5000")
    print("3. 使用管理员账户登录")
    print("4. 根据需要修改配置文件")

if __name__ == "__main__":
    main()
```

#### 10.2 创建测试脚本 (test_user_system.py)

```python
#!/usr/bin/env python3
"""
用户系统测试脚本
"""
import requests
import json
import time

class UserSystemTester:
    def __init__(self, base_url="http://127.0.0.1:5000"):
        self.base_url = base_url
        self.session = requests.Session()
    
    def test_registration(self):
        """测试用户注册"""
        print("🧪 测试用户注册...")
        
        data = {
            "username": "testuser",
            "password": "testpass123",
            "email": "test@example.com"
        }
        
        response = self.session.post(
            f"{self.base_url}/api/auth/register",
            json=data
        )
        
        result = response.json()
        
        if result.get("success"):
            print("✅ 注册测试通过")
            return True
        else:
            print("❌ 注册测试失败:", result.get("error"))
            return False
    
    def test_login(self):
        """测试用户登录"""
        print("🧪 测试用户登录...")
        
        data = {
            "username": "testuser",
            "password": "testpass123"
        }
        
        response = self.session.post(
            f"{self.base_url}/api/auth/login",
            json=data
        )
        
        result = response.json()
        
        if result.get("success"):
            print("✅ 登录测试通过")
            return True
        else:
            print("❌ 登录测试失败:", result.get("error"))
            return False
    
    def test_chat_functionality(self):
        """测试聊天功能"""
        print("🧪 测试聊天功能...")
        
        data = {
            "message": "你好，我是一个测试用户"
        }
        
        response = self.session.post(
            f"{self.base_url}/api/chat",
            json=data
        )
        
        result = response.json()
        
        if result.get("success"):
            print("✅ 聊天功能测试通过")
            return True
        else:
            print("❌ 聊天功能测试失败:", result.get("error"))
            return False
    
    def test_profile_access(self):
        """测试用户资料访问"""
        print("🧪 测试用户资料访问...")
        
        response = self.session.get(f"{self.base_url}/api/auth/profile")
        
        result = response.json()
        
        if result.get("success"):
            print("✅ 用户资料访问测试通过")
            return True
        else:
            print("❌ 用户资料访问测试失败:", result.get("error"))
            return False
    
    def run_all_tests(self):
        """运行所有测试"""
        print("🚀 开始用户系统测试...")
        
        tests = [
            self.test_registration,
            self.test_login,
            self.test_chat_functionality,
            self.test_profile_access
        ]
        
        passed = 0
        total = len(tests)
        
        for test in tests:
            try:
                if test():
                    passed += 1
            except Exception as e:
                print(f"❌ 测试异常: {e}")
        
        print(f"\n📊 测试结果: {passed}/{total} 通过")
        
        if passed == total:
            print("🎉 所有测试通过！用户系统运行正常。")
        else:
            print("⚠️  部分测试失败，请检查系统配置。")

if __name__ == "__main__":
    tester = UserSystemTester()
    tester.run_all_tests()
```

---

## 🎯 实施总结

### 核心改进点

1. **多用户隔离**: 每个用户拥有独立的数据目录和数据库记录
2. **安全认证**: JWT + Session双重认证机制
3. **数据持久化**: SQLite数据库存储用户信息和标签数据
4. **权限管理**: 基于装饰器的权限控制系统
5. **前端优化**: 现代化的登录注册界面

### 部署步骤

1. **环境准备**: 安装Python依赖包
2. **数据库初始化**: 运行部署脚本创建数据库表
3. **配置文件**: 更新config.yaml中的用户系统配置
4. **启动应用**: 运行Flask应用
5. **测试验证**: 运行测试脚本验证功能

### 安全考虑

- 密码使用PBKDF2哈希存储
- JWT令牌过期机制
- 输入数据清理和验证
- SQL注入防护
- 会话管理安全

### 扩展性

- 模块化设计便于功能扩展
- 支持多种认证方式
- 数据库结构支持复杂查询
- API设计遵循RESTful规范

这套用户系统为LightRAG标签系统提供了完整的多用户支持，确保数据安全和用户隔离，同时保持了良好的扩展性和维护性。